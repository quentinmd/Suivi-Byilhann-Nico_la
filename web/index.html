<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Suivi - Byilhann & Nico_la</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body { margin:0; padding:0; height:100%; font-family: system-ui, Arial, sans-serif; }
    #map { width:100%; height:100%; }
    .legend {
      position: absolute;
      top: 10px; left: 10px; background:#fff; padding:8px 12px; border-radius:6px; box-shadow:0 2px 6px rgba(0,0,0,.15); font-size:14px; z-index:1000;
    }
    .legend h1 { margin:0 0 6px; font-size:16px; }
    .legend small { color:#555; }
  .info-box { position:absolute; top:10px; right:10px; background:#ffffffd9; backdrop-filter: blur(4px); padding:10px 14px; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,.2); max-width:240px; font-size:13px; line-height:1.35; z-index:1000; }
    .info-box h2 { margin:0 0 6px; font-size:15px; }
    .twitch-live { color:#d40089; font-weight:600; }
    .twitch-off { color:#666; }
  .next-dest { position:absolute; left:10px; right:10px; bottom:10px; background:#ffffffd9; backdrop-filter: blur(4px); padding:10px 12px; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,.2); z-index:1000; }
  .next-dest .row { display:flex; gap:8px; align-items:baseline; font-size:14px; }
  .next-dest .bar-wrap { margin-top:6px; max-width: 360px; margin-left:auto; margin-right:auto; width: 80%; }
  .next-dest .bar { height:8px; background:#e9ecef; border-radius:6px; overflow:hidden; position:relative; }
  .next-dest .bar .fill { height:100%; background:#2a9d8f; width:0%; transition: width .6s ease; }
  .next-dest .km-label { text-align:center; font-size:12px; color:#333; margin-bottom:6px; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="legend" id="legend"></div>
  <div class="info-box" id="infoBox">
    <h2>Départ</h2>
    <div id="startInfo">Chargement...</div>
    <hr style="margin:8px 0">
    <div id="twitchStatus">Twitch: chargement...</div>
  </div>
  <!-- Bloc prochaine destination supprimé -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
  // Base API dynamique:
  // - Dev local: localhost, 127.0.0.1, réseau local (192.168.*) ou port 5173 => on cible le backend sur le même host port 4000
  // - Prod (avec reverse proxy / même domaine) => chaîne vide (chemins relatifs)
  const isLocalNet = /^192\.168\./.test(location.hostname);
  const isDev = isLocalNet || location.hostname === 'localhost' || location.hostname === '127.0.0.1' || location.port === '5173';
  // En prod, même domaine => chemins relatifs ("")
  const PROD_API_DOMAIN = '';
  const API_BASE = (window.API_BASE_OVERRIDE && window.API_BASE_OVERRIDE.trim())
    ? window.API_BASE_OVERRIDE.trim()
    : (isDev ? `${location.protocol}//${location.hostname}:4000` : PROD_API_DOMAIN);
  console.log('[Tracker] API_BASE =', API_BASE || '(chemins relatifs)');
  // Formateur durée: retourne "D j H h M min"
  function formatDHm(ms){
    const totalMin = Math.max(0, Math.floor(ms/60000));
    const days = Math.floor(totalMin / (24*60));
    const hours = Math.floor((totalMin % (24*60)) / 60);
    const minutes = totalMin % 60;
    return `${days} j ${hours} h ${minutes} min`;
  }
  function showDebug(msg){
    let box = document.getElementById('debugBox');
    if(!box){
      box = document.createElement('div');
      box.id='debugBox';
      box.style.cssText='position:absolute;bottom:10px;left:10px;background:#000c;color:#fff;padding:6px 10px;font:12px monospace;z-index:2000;border-radius:4px;max-width:320px;';
      document.body.appendChild(box);
    }
    box.innerHTML = msg;
  }
  const map = L.map('map').setView([43.604482, 3.881177], 8); // around Montpellier
  // Panes pour contrôler l'ordre d'affichage
  map.createPane('planned');
  map.getPane('planned').style.zIndex = 420;
  map.createPane('walking');
  map.getPane('walking').style.zIndex = 650;
    L.tileLayer('https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap'
    }).addTo(map);

  const state = { positions: [], route: [], marker: null, plannedLine: null, startMarker: null, lastCount: 0, initialFitted: false, startTime: null, totalKm: 0, walkingLayer: null, walkingKmTotal: 0, walkingFitted: false, startLat:null, startLng:null, startConnector:null, startConnectorKm:0 };
  const MAJOR_CITIES = new Set([
    'Montpellier (Radisson Blu)','Nîmes','Avignon','Orange','Montélimar','Valence','Vienne','Lyon','Mâcon','Chalon-sur-Saône','Beaune','Dijon','Sens','Fontainebleau','Melun','Paris (Arrivée)'
  ]);

    async function safeFetchJson(url){
      const res = await fetch(url, {headers:{'Accept':'application/json'}});
      const ct = res.headers.get('content-type')||'';
      const txt = await res.text();
      if(!txt){ throw new Error('Réponse vide '+res.status+' '+url); }
  try { return JSON.parse(txt); } catch(e){ console.error('Réponse non JSON:', {url,status:res.status, ct, bodyPreview: txt.slice(0,200)}); showDebug('Réponse non JSON pour '+url+'<br>Status '+res.status); throw e; }
    }
    async function fetchStart() { return safeFetchJson(`${API_BASE}/api/start?t=${Date.now()}`); }
    async function fetchPositions() { return safeFetchJson(`${API_BASE}/api/positions?t=${Date.now()}`); }
    async function fetchRoute() { return safeFetchJson(`${API_BASE}/api/route?t=${Date.now()}`); }
  async function fetchWalkingTrack(){ return safeFetchJson(`${API_BASE}/api/walking-track?source=sqlite&full=1&t=${Date.now()}`); }

    function updateMap() {
      // Parcours planifié (gris pointillé)
      if(state.route.length) {
        const plannedLatLngs = state.route.map(r=>[r.lat, r.lng]);
        if(!state.plannedLine) {
          state.plannedLine = L.polyline(plannedLatLngs, {color:'#777', dashArray:'4,6', weight:3, pane:'planned'}).addTo(map);
        } else {
          state.plannedLine.setLatLngs(plannedLatLngs);
        }
      }
      // Marqueur sur la dernière position (sans tracer la ligne rouge)
      const latlngs = state.positions.map(p=>[p.lat,p.lng]);
      if(latlngs.length) {
        const last = latlngs[latlngs.length-1];
        if(!state.marker) {
          state.marker = L.marker(last).addTo(map).bindPopup('Equipe position actuelle').openPopup();
        } else { state.marker.setLatLng(last); }
        if(!state.initialFitted && latlngs.length >= 2) {
          try {
            const b = L.latLngBounds(latlngs);
            map.fitBounds(b.pad(0.15), {animate:true});
            state.initialFitted = true;
          } catch(_){ }
        }
      }
    }

    function haversine(lat1, lon1, lat2, lon2){
      const R = 6371; const toRad = d => d*Math.PI/180;
      const dLat = toRad(lat2-lat1), dLon = toRad(lon2-lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(a));
    }
    function computeDistance(){
      let d=0; for(let i=1;i<state.positions.length;i++){ const A=state.positions[i-1], B=state.positions[i]; d+=haversine(A.lat,A.lng,B.lat,B.lng);} state.totalKm=d; }
  function updateWalkingLayer(geojson){
      try {
        const features = Array.isArray(geojson.features) ? geojson.features : [];
        // Calcul distance totale des segments
        let total = 0;
        for(const f of features){
          const dk = f.properties && typeof f.properties.distance_km === 'number' ? f.properties.distance_km : null;
          if(dk!=null) total += dk; else if(f.geometry && f.geometry.type==='LineString'){
            const coords = f.geometry.coordinates; // [lng,lat]
            for(let i=1;i<coords.length;i++){
              const [lng1,lat1] = coords[i-1];
              const [lng2,lat2] = coords[i];
              total += haversine(lat1,lng1,lat2,lng2);
            }
          }
        }
        state.walkingKmTotal = total;
        if(state.walkingLayer){ state.walkingLayer.remove(); state.walkingLayer = null; }
  state.walkingLayer = L.geoJSON(geojson, { pane:'walking', style: { color:'#2a9d8f', weight:5, opacity:0.95, lineCap:'round', lineJoin:'round' } }).addTo(map);
  
        try { if(state.walkingLayer && state.walkingLayer.bringToFront) state.walkingLayer.bringToFront(); } catch(_){ }
        // Assurer le segment départ -> premier point si manquant
        try {
          if(state.startConnector){ state.startConnector.remove(); state.startConnector = null; state.startConnectorKm = 0; }
          if(Number.isFinite(state.startLat) && Number.isFinite(state.startLng) && state.positions.length){
            const firstPos = state.positions[0];
            const d0 = haversine(state.startLat, state.startLng, firstPos.lat, firstPos.lng);
            // Si la couche actuelle ne touche pas le départ (distance au plus proche point > 100m), on ajoute un connecteur
            let needConnector = true;
            try {
              const b = state.walkingLayer.getBounds && state.walkingLayer.getBounds();
              if(b && b.isValid && b.isValid()){
                needConnector = b.contains([state.startLat, state.startLng]) ? false : true;
              }
            } catch(_){ }
            if(needConnector && d0 > 0.05){ // >50m
              state.startConnector = L.polyline([[state.startLat, state.startLng],[firstPos.lat, firstPos.lng]], { color:'#2a9d8f', weight:5, opacity:0.8, pane:'walking' }).addTo(map);
              state.startConnectorKm = d0;
            }
          }
        } catch(_){ }
        // Ajouter la distance du connecteur au total affiché
        state.walkingKmTotal = state.walkingKmTotal + (state.startConnectorKm || 0);
        // Auto-fit une seule fois sur la couche marche si elle est valide
        try {
          const b = state.walkingLayer.getBounds && state.walkingLayer.getBounds();
          if(b && b.isValid && b.isValid() && !state.walkingFitted){
            let fitBounds = b;
            try {
              if(state.startConnector && state.startConnector.getBounds){
                fitBounds = fitBounds.extend(state.startConnector.getBounds());
              }
            } catch(_){ }
            map.fitBounds(fitBounds.pad(0.12));
            state.walkingFitted = true;
          }
        } catch(_){ }
      } catch(e){ console.warn('updateWalkingLayer error', e); }
    }
    function routeDistance(iStart, iEnd){
      if(!state.route.length) return 0;
      const a = Math.max(0, Math.min(iStart, iEnd));
      const b = Math.max(0, Math.max(iStart, iEnd));
      let d=0; for(let i=a+1;i<=b;i++){ const A=state.route[i-1], B=state.route[i]; d += haversine(A.lat,A.lng,B.lat,B.lng);} return d;
    }
    function findNearestRouteIndex(lat,lng){
      let bestI=0, bestD=Infinity; for(let i=0;i<state.route.length;i++){ const r=state.route[i]; const dd=haversine(lat,lng,r.lat,r.lng); if(dd<bestD){ bestD=dd; bestI=i; } } return bestI;
    }
    function findPrevNextMajors(fromIdx){
      let prev = null, next = null;
      for(let i=fromIdx;i>=0;i--){ if(MAJOR_CITIES.has(state.route[i].name)){ prev = i; break; } }
      for(let i=fromIdx+1;i<state.route.length;i++){ if(MAJOR_CITIES.has(state.route[i].name)){ next = i; break; } }
      if(next==null){ // fallback sur dernière étape
        for(let i=state.route.length-1;i>=0;i--){ if(MAJOR_CITIES.has(state.route[i].name)){ next=i; break; } }
      }
      return {prev, next};
    }
  // Bloc prochaine destination supprimé
    function updateLegendDynamic(){
      if(!state.startTime) return; const startDate=new Date(state.startTime); const now=new Date();
      const diffStr = formatDHm(now - startDate);
      const hoursEl = document.querySelector('[data-hours]'); if(hoursEl) hoursEl.textContent = diffStr;
      const distEl = document.querySelector('[data-distance]'); if(distEl) {
        const km = state.walkingKmTotal && state.walkingKmTotal>0 ? state.walkingKmTotal : state.totalKm;
        distEl.textContent = km.toFixed(1) + ' km';
      }
    }
    async function refresh() {
      try {
        const data = await fetchPositions();
        const grew = data.length > state.lastCount;
        state.positions = data;
        state.lastCount = data.length;
        computeDistance();
        updateMap();
        if(grew && state.initialFitted) {
          const last = state.positions[state.positions.length-1];
          if(last) map.panTo([last.lat, last.lng], {animate:true, duration:0.8});
        }
        updateLegendDynamic();
        // recharger la trace à pied si on a ajouté un point
        if(grew){
          try { const geo = await fetchWalkingTrack(); updateWalkingLayer(geo); } catch(_){}
        }
      } catch(e) {
        console.warn('Erreur refresh positions', e);
      }
    }

    async function init() {
      let start, route;
      try {
        [start, route] = await Promise.all([fetchStart(), fetchRoute()]);
      } catch(err){
        console.error('Erreur chargement initial:', err);
        document.getElementById('legend').innerHTML = '<strong>Erreur chargement API</strong><br>'+ (err.message||'');
        showDebug('Echec init: '+(err.message||err));
        return; }
      state.route = route;
      if(start.start_lat && start.start_lng) {
        const slat = parseFloat(start.start_lat), slng = parseFloat(start.start_lng);
        state.startLat = slat; state.startLng = slng;
        if(!state.startMarker) {
          state.startMarker = L.marker([slat, slng], {title:'Départ'}).addTo(map).bindPopup('Départ');
        }
      }
      const startDate = new Date(start.start_time);
      const now = new Date();
      const diffStr = formatDHm(now - startDate);
      state.startTime = start.start_time;
      document.getElementById('legend').innerHTML = `<h1>Suivi</h1>
        <div><strong>Temps écoulé :</strong> <span data-hours>${diffStr}</span></div>
        <div><strong>Distance (à pied) :</strong> <span data-distance>0.0 km</span></div>
        <div><strong>Arrivée prévue :</strong> Paris</div>
  <div style="margin-top:6px"><span style="display:inline-block;width:14px;height:4px;background:#2a9d8f;vertical-align:middle;margin-right:4px"></span>Parcours à pied<br><span style="display:inline-block;width:14px;height:4px;background:#777;vertical-align:middle;margin-right:4px;border-bottom:2px dashed #777"></span>Parcours planifié</div>
  <small>Mise à jour auto toutes les 10s.</small>`;
      document.getElementById('startInfo').innerHTML = `${start.start_place || ''}<br>${startDate.toLocaleString('fr-FR')}`;
  await refresh();
  // Charger la trace à pied (si Firestore activé côté serveur)
  try { const geo = await fetchWalkingTrack(); updateWalkingLayer(geo); } catch(_){}
      // Si on n'a pas encore pu fitter (pas assez de points) on tente un fit départ + première étape du parcours planifié
      if(!state.initialFitted) {
        const extra = [];
        if(start.start_lat && start.start_lng) extra.push([parseFloat(start.start_lat), parseFloat(start.start_lng)]);
        if(state.route.length) extra.push([state.route[0].lat, state.route[0].lng]);
        if(extra.length >= 2) {
          try { map.fitBounds(L.latLngBounds(extra).pad(0.3)); } catch(_){}
        } else if(extra.length === 1) {
          map.setView(extra[0], 9);
        }
      }
      // Corriger potentiels glitchs de rendu après animations
      setTimeout(()=> map.invalidateSize(), 400);
  // Rafraîchissement plus réactif pour refléter vite les nouveaux points
  setInterval(refresh, 5000);
      // Twitch status refresh
      async function updateTwitch(){
        try {
          const r = await fetch(`${API_BASE}/api/twitch-status`);
          const j = await r.json();
          if(j.live){
            document.getElementById('twitchStatus').innerHTML = `<span class="twitch-live">LIVE</span> ${j.viewers ?? ''} viewers`;
          } else {
            document.getElementById('twitchStatus').innerHTML = `<span class="twitch-off">Hors ligne</span>`;
          }
        } catch(e){ document.getElementById('twitchStatus').textContent = 'Twitch indisponible'; }
      }
      updateTwitch();
      setInterval(updateTwitch, 60000);
  // Si après 3s le contenu de startInfo n'a pas changé, afficher debug
  setTimeout(()=>{ /* debug initial désactivé en prod */ }, 3000);
    }

    init();
  </script>
</body>
</html>
